<!DOCTYPE html>
<html lang="en">
<title>&#127912 NZ Art Server</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100&display=swap" rel="stylesheet">

<head>
    <meta name="description"
        content="NZ Art App - Use the power of Stable-Diffusion to create mind blowing art from just a text description">
    <meta property="og:type" content="website" />
    <meta property="og:locale" content="en_NZ" />
    <meta property="og:url" content="https://nzart.app" />
    <meta property="og:title" content="NZ Art App" />
    <meta property="og:description"
        content="Create mind blowing art in seconds for free. Utilizing stable-diffusion this text-to-image model enables multiple high resolution images to be wished into existence at a time." />
    <meta property="og:image" content="https://artificialartifacts9b50.blob.core.windows.net/www/nzart-app.jpg" />
    <link rel="apple-touch-icon" sizes="180x180"
        href="https://artificialartifacts9b50.blob.core.windows.net/www/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32"
        href="https://artificialartifacts9b50.blob.core.windows.net/www/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16"
        href="https://artificialartifacts9b50.blob.core.windows.net/www/favicon-16x16.png">
    <link rel="manifest"
        href="https://nzart.app/api/read?resource=site.webmanifest&code=YCW-FUCxhNKbgYs7u0QnNFAfP9-memmVW9ptBFAg6tPWAzFufEQdHg==">
    <meta charset="utf-8">
    <title>Image Loader</title>
    <style>
        body {
            font-family: Arial;
            overflow: scroll;
            max-width: 1088px;
            height: 100%;
            background-repeat: no-repeat;
            background-attachment: fixed;
            margin: auto;
            overflow: scroll;
            background: linear-gradient(33deg, #007029, #49c443)fixed;
            overflow-x: hidden;
            text-align: center;
            font-family: 'Roboto', sans-serif;
            /*margin-top: 15%;
            margin-left: 39%;*/
        }

        img {
            scale: 1;
            animation: fadein 1s ease-in-out;
            border: white;
            border-radius: 20px;
            border-style: solid;
            border-width: thick;
        }

        .container {
            height: auto;
            display: flex;
        }

        h1 {
            font-size: xx-large;
            font-weight: 500;
            color: white;
            font-family: fantasy;
            animation: fadein 1s ease-in-out;
        }

        h2 {
            animation: fadein 1s ease-in-out;
            font-family: fantasy;
            color: white;
            font-weight: 200;
        }

        .prompttext {
            font-size: large;
            color: white;
            font-family: fantasy;
            margin-top: 90%;
            margin-left: 39%;
            animation: fadein 1s ease-in-out;
        }

        .header {
            align-items: center;
            animation: fadein 1s ease-in-out;
            position: absolute;
            top: 20px;
        }

        .header>h1 {
            font-size: xx-large;
            color: white;
        }

        .footer {
            align-items: center;
        }

        .footer>h1 {
            font-size: xx-large;
            color: white;
        }

        #intro {
            font-size: xx-large;
            color: white;
            font-weight: 400;
        }

        @keyframes fadein {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
    </style>
    <script type="text/javascript">
        const state = [];

        function load(index) {
            console.log(`index: ${index}`);
            setTimeout(function () {
                if (index >= 0) {
                    var img = new Image();

                    //sort state based off data format of Sat, 01 Oct 2022 20:58:16 GMT
                    state.sort(function (a, b) {
                        return new Date(a.InsertionTime) - new Date(b.InsertionTime);
                    });
                    //console.log(`state: ${state[0].InsertionTime}`);

                    //iterate through state logging the insertion time of each entity
                    for (var i = 0; i < state.length; i++) {
                        console.log(`state: ${state[i].InsertionTime}`);
                    }

                    var queueCount = Number(state[index].DequeueCount);
                    var receipt = state[index].PopReceipt;
                    var id = state[index].MessageId;
                    var decoded = atob(state[index].MessageText);
                    var selected = JSON.parse(decoded);

                    document.getElementById("prompttext").innerHTML = `${selected.PromptText}`; //- ${state[index].InsertionTime}`;
                    document.getElementById("presenter").innerHTML = `${selected.DisplayName} presents...`;

                    img.src = `https://nzart.app/api/downloader?prompt=${selected.PromptText}&seed=${selected.Seeds}`;
                    //if image isn't in container add it, otherwise replace it
                    if (document.getElementById("container").children.length > 0) {
                        document.getElementById("container").replaceChild(img, document.getElementById("container").children[0]);
                    } else {
                        document.getElementById("container").appendChild(img);
                    }
                    if (state.length >= 5) {
                        //State is already sorted, so we should be able to delete the first item
                        if (id != undefined && receipt != undefined) {
                            console.log(`Deleting: ${JSON.stringify(state[0])}`);
                            //also removing it from state, so this doesn't trigger contiunously                  
                            fetch(`https://nzart.app/api/queue-fetcher?id=${state[0].MessageId}&receipt=${state[0].PopReceipt}&code=RNCJOcxB66TXjTvtRGP8FJ9ZiLriakVw9ev09azhcNTMAzFu5a6hfg==`).then(function (response) {
                                console.log(`Deleted: ${JSON.stringify(response)}`);
                            });
                            //remove from state after deleting
                            state.splice(state[0], 1);
                        }
                    }

                    load(index - 1);
                }
                if (index == 0) {
                    console.log(`Shown all, going back to the top`);
                    index = state.length;
                    //new event type of finishedRender
                    var event = new Event('finishedRender');
                    document.dispatchEvent(event);
                    console.log("Displayed all fetched images, requesting more");
                }
            }, 7000);
        }

        document.addEventListener('finishedRender', function (e) {
            console.log("Finished rendering, requesting more");
            fetchPrompts();
        });

        function fetchPrompts() {
            //preload - Doggo, Kitten, Octopus,Hippo,Unicorn
            try {
                fetch("https://nzart.app/api/queue-fetcher?code=RNCJOcxB66TXjTvtRGP8FJ9ZiLriakVw9ev09azhcNTMAzFu5a6hfg==").then(function (response) {
                    return response.json();
                }).then(function (data) {
                    var qMessages = data.QueueMessagesList?.QueueMessage;
                    if (qMessages != undefined) {
                        //check type of qMessages
                        if (Array.isArray(qMessages)) {
                            //iterate through qMessages
                            for (var i = 0; i < qMessages.length; i++) {
                                var element = qMessages[i];
                                //base64 decode the message
                                var decoded = atob(element.MessageText);
                                //parse the json
                                var json = JSON.parse(decoded);

                                //only add to state if the prompt value is not already in state
                                if (state.filter(x => JSON.parse(atob(x.MessageText)).PromptText == json.PromptText).length == 0) {
                                    if (json.Source == "client") {
                                        console.log(`Prompt:${json.PromptText} does not exist in state, adding to state:DequeueCount:${element.DequeueCount}`);
                                        state.push(element);
                                    }
                                }
                            }
                            console.log(`Loaded ${state.length} items into state`);

                            load(state.length - 1);

                        }
                        else {
                            var decoded = atob(qMessages.MessageText);
                            var json = JSON.parse(decoded);

                            //we don't want to add duplicates to state                           
                            if (state.filter(x => JSON.parse(atob(x.MessageText)).PromptText == json.PromptText).length == 0) {
                                if (json.Source == "client") {
                                    console.log(`Prompt:${json.PromptText} does not exist in state, adding to state`);
                                    state.push(qMessages);
                                }
                            }

                            //There's only one entry, qMessages is not an array, so just load it                      
                            load(0);
                        }
                        console.log(`Loaded ${state.length} unique items into state`);
                    }
                });
            }
            catch (e) {
                console.error(e);
                //Hopefully just a transient error, so try again
                sleep(2000);
                fetchPrompts(0);
            }
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    </script>
</head>
<div id="intro">
    <h1>Big Day Out - Art Exhibition</h1>
</div>
<div id="header">
    <h1 id="presenter"></h1>
</div>

<body onload="fetchPrompts()">
    <flexbox id="container"></flexbox>
</body>
<footer>
    <h1 id="prompttext"></h1>
</footer>

</html>